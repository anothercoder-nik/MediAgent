
import os
import fitz  # PyMuPDF
import re
from markdown import markdown
from bs4 import BeautifulSoup
from reportlab.platypus import Paragraph

from openai import OpenAI
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, PageBreak, Image,
    Table, TableStyle, HRFlowable
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.pagesizes import A4
from reportlab.lib.enums import TA_JUSTIFY, TA_CENTER, TA_LEFT
from reportlab.lib.units import inch
from reportlab.lib import colors
from datetime import datetime
from dotenv import load_dotenv



load_dotenv()

client = OpenAI(
    base_url="https://openrouter.ai/api/v1",
    api_key=os.getenv("OPENAI_API_KEY")
)

def cover_page(canvas, doc):
    canvas.saveState()
    width, height = A4
    if os.path.exists("logo.png"):
        canvas.drawImage("logo.png", width/2-80, height-250, width=160, height=160, preserveAspectRatio=True)
    canvas.setFont("Helvetica-Bold", 24)
    canvas.drawCentredString(width/2, height-280, "AI-Based Medical Diagnostic Report")
    canvas.setFont("Helvetica", 15)
    canvas.drawCentredString(width/2, height-320, "Generated by Medical Agent System")
    canvas.setFont("Helvetica", 10)
    canvas.drawCentredString(width/2, height-335, f"Report generated: {datetime.now().strftime('%d %b %Y, %I:%M %p')}")
    canvas.setFont("Helvetica-Oblique", 10)
    canvas.drawString(50, 40, "Confidential – For clinical use only")
    canvas.drawRightString(width-50, 40, f"Page {doc.page}")
    canvas.restoreState()

def other_pages(canvas, doc):
    canvas.saveState()
    width, height = A4
    canvas.setFont("Helvetica-Oblique", 9)
    canvas.drawString(50, 40, "Medical Agent | Confidential")
    canvas.drawRightString(width-50, 40, f"Page {doc.page}")
    canvas.setStrokeColor(colors.grey)
    canvas.setLineWidth(0.5)
    canvas.line(50, 50, width-50, 50)
    canvas.restoreState()

def extract_text_from_pdf(file_path):
    doc = fitz.open(file_path)
    return "\n".join(page.get_text() for page in doc).strip()

# def structure_medical_report(raw_text):
#     prompt = f"""
# You are a medical assistant. Structure the following unstructured medical report into clearly defined sections:
# Patient Info, Symptoms, History, Medications, Exam Findings, Test Results, Diagnosis, Other Notes.
# Here is the raw text:
# \"\"\"{raw_text}\"\"\"
# """
#     resp = client.chat.completions.create(
#         model="meta-llama/llama-4-maverick",
#         messages=[{"role": "user", "content": prompt}],
#         temperature=0.4
#     )
#     return resp.choices[0].message.content.strip()
def structure_medical_report(raw_text):
    prompt = f"""
You are a medical documentation specialist. Structure the following unstructured medical report into clearly defined sections with proper formatting.

Please format your response exactly as follows:

## PATIENT INFORMATION
[Extract and organize patient demographics, identifiers, dates]

## CHIEF COMPLAINT
[Primary reason for visit/consultation]

## HISTORY OF PRESENT ILLNESS
[Detailed narrative of current condition]

## PAST MEDICAL HISTORY
[Previous medical conditions, surgeries, hospitalizations]

## MEDICATIONS
[Current medications, dosages, frequency]

## ALLERGIES
[Known allergies and reactions]

## SOCIAL HISTORY
[Relevant social factors, occupation, lifestyle]

## FAMILY HISTORY
[Relevant family medical history]

## REVIEW OF SYSTEMS
[Systematic review by body systems]

## PHYSICAL EXAMINATION
[Vital signs and physical exam findings]

## DIAGNOSTIC TESTS/RESULTS
[Laboratory, imaging, and other test results]

## ASSESSMENT/IMPRESSION
[Clinical impressions and diagnoses]

## PLAN
[Treatment plan and follow-up]

## OTHER NOTES
[Any additional relevant information]

---

Raw Medical Text:
\"\"\"{raw_text}\"\"\"
"""
    resp = client.chat.completions.create(
        model="meta-llama/llama-4-maverick",
        messages=[{"role":"user","content":prompt}],
        temperature=0.4
    )
    return resp.choices[0].message.content.strip()
class BaseAgent:
    def __init__(self, report_text):
        self.report_text = report_text
    def build_prompt(self): raise NotImplementedError
    def run(self):
        prompt = self.build_prompt()
        try:
            resp = client.chat.completions.create(
                model="meta-llama/llama-4-maverick",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.5
            )
            return resp.choices[0].message.content.strip()
        except Exception as e:
            print("[ERROR]", e)
            return None

class Cardiologist(BaseAgent):
    def build_prompt(self):
        return f"""
You are a senior Cardiologist with expertise in cardiovascular medicine. Analyze the following structured medical report and provide your professional assessment.

Please format your response exactly as follows:

## CARDIOLOGY ASSESSMENT

**Primary Diagnosis:** [Your primary cardiovascular diagnosis or "No significant cardiovascular findings"]

**Confidence Level:** [0-100]%

**Risk Assessment:** [Low/Medium/High]

**Clinical Findings:**
• [Key cardiovascular findings from the report]
• [Additional relevant findings]

**Recommended Investigations:**
• [Specific cardiovascular tests/procedures]
• [Additional diagnostic workup if needed]

**Management Recommendations:**
• [Treatment recommendations]
• [Follow-up care]

**Additional Notes:**
[Any additional cardiovascular considerations or differential diagnoses]

---

Medical Report:
\"\"\"{self.report_text}\"\"\"
"""

class Psychologist(BaseAgent):
    def build_prompt(self):
        return f"""
You are a licensed Clinical Psychologist with expertise in mental health assessment. Analyze the following structured medical report and provide your professional psychological evaluation.

Please format your response exactly as follows:

## PSYCHOLOGICAL ASSESSMENT

**Primary Diagnosis:** [Your primary psychological/psychiatric diagnosis or "No significant psychological findings"]

**Confidence Level:** [0-100]%

**Risk Assessment:** [Low/Medium/High]

**Clinical Findings:**
• [Key psychological/behavioral findings from the report]
• [Mental status observations]
• [Relevant psychological symptoms]

**Recommended Evaluations:**
• [Specific psychological assessments/tests]
• [Additional mental health evaluations]

**Management Recommendations:**
• [Therapeutic interventions]
• [Psychological support recommendations]

**Additional Notes:**
[Any additional psychological considerations, risk factors, or differential diagnoses]

---

Medical Report:
\"\"\"{self.report_text}\"\"\"
"""

class Pulmonologist(BaseAgent):
    def build_prompt(self):
        return f"""
You are a board-certified Pulmonologist with expertise in respiratory medicine. Analyze the following structured medical report and provide your professional pulmonary assessment.

Please format your response exactly as follows:

## PULMONOLOGY ASSESSMENT

**Primary Diagnosis:** [Your primary respiratory diagnosis or "No significant pulmonary findings"]

**Confidence Level:** [0-100]%

**Risk Assessment:** [Low/Medium/High]

**Clinical Findings:**
• [Key respiratory findings from the report]
• [Pulmonary function observations]
• [Relevant respiratory symptoms]

**Recommended Investigations:**
• [Specific pulmonary function tests]
• [Imaging studies (chest X-ray, CT, etc.)]
• [Additional respiratory diagnostics]

**Management Recommendations:**
• [Treatment recommendations]
• [Respiratory therapy suggestions]

**Additional Notes:**
[Any additional pulmonary considerations, occupational factors, or differential diagnoses]

---

Medical Report:
\"\"\"{self.report_text}\"\"\"
"""

class MultidisciplinaryTeam:
    def __init__(self, cardio, psycho, pulmo):
        self.reports = {"Cardiologist": cardio, "Psychologist": psycho, "Pulmonologist": pulmo}
    def run(self):
        prompt = f"""
You are a senior attending physician leading a multidisciplinary medical team. Review the specialist assessments below and provide a comprehensive, unified medical opinion.

Please format your response exactly as follows:

# MULTIDISCIPLINARY MEDICAL ASSESSMENT

## EXECUTIVE SUMMARY
[Brief 2-3 sentence overview of the case]

## SPECIALIST FINDINGS SYNTHESIS

**Cardiology:** [Summary of key cardiovascular findings]
**Psychology:** [Summary of key psychological findings]  
**Pulmonology:** [Summary of key respiratory findings]

## UNIFIED DIAGNOSIS

**Primary Diagnosis:** [Most likely primary diagnosis]
**Secondary Diagnoses:** [Additional relevant diagnoses]
**Differential Diagnoses:** [Other conditions to consider]

## RISK STRATIFICATION

**Overall Risk Level:** [Low/Medium/High]
**Immediate Concerns:** [Any urgent issues requiring immediate attention]
**Long-term Considerations:** [Chronic management needs]

## COMPREHENSIVE MANAGEMENT PLAN

**Immediate Actions:**
• [Urgent interventions needed]
• [Emergency protocols if applicable]

**Diagnostic Workup:**
• [Priority investigations]
• [Follow-up tests required]

**Treatment Recommendations:**
• [Medical management]
• [Therapeutic interventions]
• [Lifestyle modifications]

**Follow-up Care:**
• [Specialist referrals]
• [Monitoring schedule]
• [Patient education needs]

## PROGNOSIS
**Short-term:** [Expected outcomes in days/weeks]
**Long-term:** [Expected outcomes in months/years]

## CONFIDENCE ASSESSMENT
**Overall Diagnostic Confidence:** [0-100]%
**Key Uncertainties:** [Areas requiring further clarification]

---

SPECIALIST REPORTS:

### CARDIOLOGY ASSESSMENT
{self.reports['Cardiologist']}

### PSYCHOLOGICAL ASSESSMENT  
{self.reports['Psychologist']}

### PULMONOLOGY ASSESSMENT
{self.reports['Pulmonologist']}
"""
        resp = client.chat.completions.create(
            model="meta-llama/llama-4-maverick",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.5
        )
        return resp.choices[0].message.content.strip()

def patient_summary_section(structured_text):
    info, symptoms, diagnosis, urgency = "Not available", "Not listed", "–", "–"
    
    # Parse the markdown structured text
    lines = structured_text.split("\n")
    current_section = ""
    
    for line in lines:
        line = line.strip()
        
        # Identify sections
        if line.startswith("## PATIENT INFORMATION"):
            current_section = "patient"
            continue
        elif line.startswith("## CHIEF COMPLAINT"):
            current_section = "symptoms"
            continue
        elif line.startswith("## ASSESSMENT/IMPRESSION") or line.startswith("## DIAGNOSIS"):
            current_section = "diagnosis"
            continue
        elif line.startswith("##"):
            current_section = ""
            continue
            
        # Extract content based on current section
        if current_section == "patient" and line and not line.startswith("#"):
            if info == "Not available":
                info = line
            else:
                info += " " + line
        elif current_section == "symptoms" and line and not line.startswith("#"):
            if symptoms == "Not listed":
                symptoms = line
            else:
                symptoms += " " + line
        elif current_section == "diagnosis" and line and not line.startswith("#"):
            if diagnosis == "–":
                diagnosis = line
            else:
                diagnosis += " " + line
    
    # Limit text length for table display but keep it readable
    info = info[:200] + "..." if len(info) > 200 else info
    symptoms = symptoms[:150] + "..." if len(symptoms) > 150 else symptoms
    diagnosis = diagnosis[:150] + "..." if len(diagnosis) > 150 else diagnosis
    
    return [
        ["Patient Information", info],
        ["Chief Complaint", symptoms],
        ["Primary Assessment", diagnosis],
        ["Report Status", "Complete"]
    ]

# def parse_markdown_to_pdf(text, styles):
#     """Convert markdown-formatted text to PDF elements with proper styling"""
#     elements = []
#     lines = text.split('\n')
    
#     i = 0
#     while i < len(lines):
#         line = lines[i].strip()
        
#         if not line:
#             elements.append(Spacer(1, 0.1*inch))
#             i += 1
#             continue
            
#         # Handle main headers (# )
#         if line.startswith('# '):
#             header_text = line[2:].strip()
#             elements.append(Paragraph(header_text, styles["MainHeader"]))
#             elements.append(Spacer(1, 0.2*inch))
            
#         # Handle sub headers (## )
#         elif line.startswith('## '):
#             header_text = line[3:].strip()
#             elements.append(Paragraph(header_text, styles["SubHeader"]))
#             elements.append(Spacer(1, 0.15*inch))
            
#         # Handle sub-sub headers (### )
#         elif line.startswith('### '):
#             header_text = line[4:].strip()
#             elements.append(Paragraph(header_text, styles["SubSubHeader"]))
#             elements.append(Spacer(1, 0.1*inch))
            
#         # Handle bullet points (• )
#         elif line.startswith('• '):
#             bullet_text = line[2:].strip()
#             # Process bold text in bullets
#             bullet_text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', bullet_text)
#             elements.append(Paragraph(f"• {bullet_text}", styles["BulletBody"]))
            
#         # Handle bold text lines (**text**)
#         elif '**' in line:
#             # Extract bold sections and convert to HTML
#             formatted_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
#             elements.append(Paragraph(formatted_line, styles["Body"]))
            
#         # Handle horizontal rules (---)
#         elif line.startswith('---'):
#             elements.append(HRFlowable(width="80%", thickness=1, color=colors.grey))
#             elements.append(Spacer(1, 0.1*inch))
            
#         # Regular text
#         else:
#             if line.strip():
#                 elements.append(Paragraph(line, styles["Body"]))
        
#         i += 1
    
#     return elements



def parse_markdown_to_pdf(markdown_text, styles):
    """
    Enhanced markdown to PDF converter that preserves formatting
    """
    # Convert Markdown to HTML
    html_content = markdown(markdown_text, extensions=['tables', 'nl2br'])
    
    # Parse HTML using BeautifulSoup
    soup = BeautifulSoup(html_content, 'html.parser')
    
    elements = []

    def process_element(elem):
        """Recursively process HTML elements"""
        if isinstance(elem, str):
            # Text node
            text = elem.strip()
            if text:
                return text
            return ""
        
        if elem.name == 'h1':
            elements.append(Spacer(1, 0.1 * inch))
            elements.append(Paragraph(clean_text_for_pdf(elem), styles['MainHeader']))
            elements.append(Spacer(1, 0.1 * inch))
        
        elif elem.name == 'h2':
            elements.append(Spacer(1, 0.08 * inch))
            elements.append(Paragraph(clean_text_for_pdf(elem), styles['SubHeader']))
            elements.append(Spacer(1, 0.06 * inch))
        
        elif elem.name == 'h3':
            elements.append(Spacer(1, 0.06 * inch))
            elements.append(Paragraph(clean_text_for_pdf(elem), styles['SubSubHeader']))
            elements.append(Spacer(1, 0.04 * inch))
        
        elif elem.name == 'p':
            text_content = clean_text_for_pdf(elem)
            if text_content.strip():
                elements.append(Paragraph(text_content, styles['Body']))
                elements.append(Spacer(1, 0.06 * inch))
        
        elif elem.name in ['ul', 'ol']:
            elements.append(Spacer(1, 0.04 * inch))
            for li in elem.find_all('li', recursive=False):
                bullet = "•" if elem.name == 'ul' else f"{len(elements)}."
                list_text = clean_text_for_pdf(li)
                elements.append(Paragraph(f'{bullet} {list_text}', styles['BulletBody']))
            elements.append(Spacer(1, 0.04 * inch))
        
        elif elem.name == 'blockquote':
            text_content = clean_text_for_pdf(elem)
            elements.append(Paragraph(f"<i>{text_content}</i>", styles['Body']))
            elements.append(Spacer(1, 0.06 * inch))
        
        elif elem.name == 'table':
            # Handle tables (basic implementation)
            table_data = []
            for row in elem.find_all('tr'):
                row_data = []
                for cell in row.find_all(['td', 'th']):
                    cell_text = clean_text_for_pdf(cell)
                    row_data.append(Paragraph(cell_text, styles['Body']))
                table_data.append(row_data)
            
            if table_data:
                from reportlab.platypus import Table, TableStyle
                table = Table(table_data)
                table.setStyle(TableStyle([
                    ('BOX', (0, 0), (-1, -1), 1, colors.black),
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                ]))
                elements.append(table)
                elements.append(Spacer(1, 0.1 * inch))
        
        elif elem.name in ['br']:
            elements.append(Spacer(1, 0.02 * inch))
    
    # Process all top-level elements
    for elem in soup.contents:
        if hasattr(elem, 'name'):
            process_element(elem)
    
    return elements

def clean_text_for_pdf(element):
    """
    Extract text from HTML element while preserving ReportLab formatting
    """
    if isinstance(element, str):
        return element.strip()
    
    text = ""
    for child in element.children:
        if isinstance(child, str):
            text += child
        elif child.name == 'strong' or child.name == 'b':
            text += f"<b>{clean_text_for_pdf(child)}</b>"
        elif child.name == 'em' or child.name == 'i':
            text += f"<i>{clean_text_for_pdf(child)}</i>"
        elif child.name == 'u':
            text += f"<u>{clean_text_for_pdf(child)}</u>"
        elif child.name == 'code':
            text += f"<font name='Courier'>{clean_text_for_pdf(child)}</font>"
        elif child.name == 'br':
            text += "<br/>"
        else:
            # For other tags, just extract text
            text += clean_text_for_pdf(child)
    
    return text.strip()


def generate_report_pdf(output_path, structured, diag_map, final):
    doc = SimpleDocTemplate(
        output_path, pagesize=A4, leftMargin=50, rightMargin=50, topMargin=72, bottomMargin=72
    )
    
    styles = getSampleStyleSheet()
    
    # Custom Styles - Adding all required styles
    styles.add(ParagraphStyle(
        "MainHeader", 
        fontSize=18, 
        leading=22, 
        alignment=TA_CENTER, 
        spaceAfter=16, 
        spaceBefore=8,
        textColor=colors.HexColor("#2e5a87"),
        fontName='Helvetica-Bold'
    ))
    
    styles.add(ParagraphStyle(
        "SubHeader", 
        fontSize=14, 
        leading=18, 
        alignment=TA_LEFT, 
        spaceAfter=8, 
        spaceBefore=12,
        textColor=colors.HexColor("#286245"),
        fontName='Helvetica-Bold'
    ))
    
    styles.add(ParagraphStyle(
        "SubSubHeader", 
        fontSize=12, 
        leading=16, 
        alignment=TA_LEFT, 
        spaceAfter=6, 
        spaceBefore=8,
        textColor=colors.HexColor("#444444"),
        fontName='Helvetica-Bold'
    ))
    
    styles.add(ParagraphStyle(
        "Body", 
        fontSize=11, 
        leading=14, 
        alignment=TA_JUSTIFY,
        spaceAfter=4,
        fontName='Helvetica'
    ))
    
    styles.add(ParagraphStyle(
        "BulletBody", 
        fontSize=11, 
        leading=14, 
        alignment=TA_LEFT,
        spaceAfter=3,
        leftIndent=20,
        fontName='Helvetica'
    ))
    
    styles.add(ParagraphStyle(
        "Header", 
        fontSize=18, 
        leading=22, 
        alignment=TA_CENTER, 
        spaceAfter=16, 
        textColor=colors.HexColor("#2e5a87"),
        fontName='Helvetica-Bold'
    ))
    
    styles.add(ParagraphStyle(
        "TOCEntry", 
        fontSize=12, 
        leading=16, 
        alignment=TA_LEFT, 
        spaceAfter=6, 
        leftIndent=20, 
        fontName='Helvetica'
    ))

    Story = []

    # --- DEBUG LOG ---
    print("===== PDF Generation Start =====")
    print(f"Structured Report Length: {len(structured) if structured else 0}")
    print(f"Diagnoses Received: {list(diag_map.keys()) if diag_map else []}")
    print(f"Final Summary Length: {len(final) if final else 0}")
    print(f"Output Path: {output_path}")
    print("================================")

    # --- Cover Page ---
    Story.append(PageBreak())  # Placeholder cover, real design in cover_page()

    # --- Table of Contents ---
    Story.append(Paragraph("Table of Contents", styles["Header"]))
    Story.append(Spacer(1, 0.2 * inch))
    toc_entries = [
        "1. Patient Summary",
        "2. Structured Medical Report", 
        "3. Cardiologist Assessment",
        "4. Psychologist Assessment",
        "5. Pulmonologist Assessment",
        "6. Final Multidisciplinary Summary"
    ]
    for entry in toc_entries:
        Story.append(Paragraph(entry, styles["TOCEntry"]))
    Story.append(PageBreak())

    # --- Patient Summary Table ---
    Story.append(Paragraph("Patient Summary", styles["Header"]))
    try:
        summary_data = patient_summary_section(structured) if structured else [["Summary", "No structured data available"]]
    except Exception as e:
        print("[ERROR] patient_summary_section failed:", str(e))
        summary_data = [["Summary", "Could not parse structured data."]]
    
    table_data = []
    for row in summary_data:
        table_data.append([
            Paragraph(f"<b>{row[0]}</b>", styles["Body"]),
            Paragraph(str(row[1]), styles["Body"])
        ])
    
    summary_table = Table(table_data, colWidths=[140, 380])
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#eaeaea')),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 11),
        ('LINEABOVE', (0, 0), (-1, 0), 1, colors.HexColor('#2e5a87')),
        ('BOX', (0, 0), (-1, -1), 1, colors.grey),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('LEFTPADDING', (0, 0), (-1, -1), 8),
        ('RIGHTPADDING', (0, 0), (-1, -1), 8),
        ('TOPPADDING', (0, 0), (-1, -1), 8),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
    ]))
    Story.append(summary_table)
    Story.append(PageBreak())

    # --- Structured Medical Report ---
    if structured:
        Story.append(Paragraph("Structured Medical Report", styles["Header"]))
        Story.append(HRFlowable(width="100%", thickness=2, color=colors.HexColor("#2e5a87")))
        Story.append(Spacer(1, 0.2 * inch))
        try:
            structured_elements = parse_markdown_to_pdf(structured, styles)
            Story.extend(structured_elements)
        except Exception as e:
            print("[ERROR] parse_markdown_to_pdf for structured failed:", str(e))
            Story.append(Paragraph(str(structured), styles["Body"]))
        Story.append(PageBreak())

    # --- Specialist Diagnoses ---
    if diag_map:
        for role, txt in diag_map.items():
            if txt:  # Only process if content exists
                color_map = {
                    "Cardiologist": "#f5c444",
                    "Psychologist": "#89c3eb",
                    "Pulmonologist": "#d1e189"
                }
                back_color = color_map.get(role, "#ededed")
                Story.append(Paragraph(role, ParagraphStyle("SpecHeader", parent=styles["Header"], backColor=colors.HexColor(back_color))))
                Story.append(HRFlowable(width="50%", thickness=1, color=colors.HexColor(back_color)))
                Story.append(Spacer(1, 0.15 * inch))
                try:
                    specialist_elements = parse_markdown_to_pdf(txt, styles)
                    Story.extend(specialist_elements)
                except Exception as e:
                    print(f"[ERROR] parse_markdown_to_pdf for {role} failed:", str(e))
                    Story.append(Paragraph(str(txt), styles["Body"]))
                Story.append(PageBreak())

    # --- Final Multidisciplinary Summary ---
    if final:
        Story.append(Paragraph("Final Multidisciplinary Summary", styles["Header"]))
        Story.append(HRFlowable(width="40%", thickness=1, color=colors.HexColor("#286245")))
        Story.append(Spacer(1, 0.2 * inch))
        try:
            final_elements = parse_markdown_to_pdf(final, styles)
            Story.extend(final_elements)
        except Exception as e:
            print("[ERROR] parse_markdown_to_pdf for final summary failed:", str(e))
            Story.append(Paragraph(str(final), styles["Body"]))

    # --- Build the PDF ---
    try:
        doc.build(Story, onFirstPage=cover_page, onLaterPages=other_pages)
        print("[SUCCESS] PDF Generated at:", output_path)
        return True
    except Exception as e:
        print("[FATAL ERROR] Failed to build PDF:", str(e))
        return False